rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    /// Check if request is from Worker (service account)
    /// Workers use service account credentials with custom claim 'worker: true'
    function isWorker() {
      return request.auth.token.get('worker', false) == true ||
             request.auth.token.firebase.sign_in_provider == 'service_account';
    }

    /// Check if user owns the document
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // ============================================
    // USERS COLLECTION (Restricted - Worker-only writes)
    // ============================================
    match /users/{userId} {
      // Users can ONLY READ their own document
      allow read: if isOwner(userId);
      
      // ✅ CREATE: Client only (signup), Worker never creates
      allow create: if isOwner(userId) && 
                       validateNewUserDocument(request.resource.data);
      
      // ✅ UPDATE: ONLY Worker for coins/referrals/withdrawals
      //    Client can update profile fields only
      allow update: if isWorker() || 
                       (isOwner(userId) && 
                        validateClientUpdate(resource.data, request.resource.data));
      
      // ✅ DELETE: Never allowed
      allow delete: if false;

      // Helper: Validate new user document on creation
      function validateNewUserDocument(data) {
        return data.size() >= 8 &&
               data.keys().hasAll(['uid', 'email', 'displayName', 'coins', 
                                   'dailyStreak', 'referralCode', 'createdAt', 'referredBy']) &&
               data.uid is string &&
               data.email is string &&
               data.displayName is string &&
               data.coins is number &&
               data.coins == 0 && // New users start with 0 coins
               data.dailyStreak is map &&
               data.referralCode is string &&
               data.referralCode.size() >= 6 &&
               data.createdAt is timestamp &&
               (data.referredBy == null || data.referredBy is string) &&
               data.watchedAdsToday is number &&
               data.watchedAdsToday == 0 &&
               data.lastAdResetDate is timestamp &&
               data.totalSpins is number &&
               data.totalSpins == 3 &&
               data.lastSpinResetDate is timestamp &&
               data.totalReferrals is number &&
               data.totalReferrals == 0;
      }

      // Helper: Validate CLIENT updates (profile only, no coins/referrals)
      function validateClientUpdate(oldData, newData) {
        // Clients can ONLY update: displayName, settings
        // They CANNOT update: coins, referralCode, referredBy, createdAt, etc.
        
        let immutableFieldsUnchanged = 
          newData.uid == oldData.uid &&
          newData.email == oldData.email &&
          newData.referralCode == oldData.referralCode &&
          newData.createdAt == oldData.createdAt &&
          newData.coins == oldData.coins &&  // ← Prevent coin tampering
          newData.referredBy == oldData.referredBy;  // ← Prevent referral tampering
        
        return immutableFieldsUnchanged;
      }

      // Action Log Subcollection - immutable audit trail for fraud detection
      // Only the client can write (with server-side timestamp validation)
      match /actions/{actionId} {
        allow read: if request.auth.uid == userId;
        allow create: if request.auth.uid == userId &&
                         validateAction(request.resource.data);
        allow update, delete: if false; // Immutable once created
      }

      // Monthly Stats Subcollection - only Worker writes
      match /monthly_stats/{yearMonth} {
        allow read: if request.auth.uid == userId;
        allow create, update: if isWorker();  // ← Only Worker writes
        allow delete: if false;
      }

      // Fraud Logs Subcollection - only Worker writes for security auditing
      match /fraud_logs/{logId} {
        allow read: if isOwner(userId);  // Users can read (but need proper UI)
        allow create: if isWorker();  // Only Worker logs fraud events
        allow update, delete: if false;  // Immutable
      }

      // Helper: Validate action (audit trail)
      // Actions are an immutable client-facing audit trail. We allow
      // positive reward actions (GAME_WON, AD_WATCHED, etc.) and
      // special negative actions (WITHDRAWAL_REQUEST) if the client
      // creates them as a fallback. Prefer Worker writes for sensitive ops.
      function validateAction(data) {
        return data.size() >= 4 &&
               data.keys().hasAll(['type', 'amount', 'timestamp', 'userId']) &&
               (data.type == 'GAME_WON' || 
                data.type == 'AD_WATCHED' || 
                data.type == 'SPIN_REWARD' ||
                data.type == 'DAILY_STREAK_REWARD' ||
                data.type == 'DAILY_SPIN_RESET') &&
               data.amount is number &&
               data.amount > 0 &&
               data.timestamp is timestamp &&
               data.userId is string &&
               data.userId == userId;
      }
    }

    // ============================================
    // WITHDRAWALS COLLECTION (Worker-only writes)
    // ============================================
    match /withdrawals/{withdrawalId} {
      // ✅ READ: Users can read their own, admins read all
      allow read: if request.auth != null && 
                     (request.auth.uid == resource.data.userId || 
                      request.auth.token.admin == true);
      
      // ✅ CREATE: Only Worker (not client) - prevents tampering
      allow create: if isWorker() &&
                       validateWithdrawalCreation(request.resource.data);
      
      // ✅ UPDATE: Only admins can approve/reject
      allow update: if request.auth.token.admin == true &&
                       validateWithdrawalUpdate(resource.data, request.resource.data);
      
      allow delete: if false; // Cannot delete withdrawals
    }

    // Helper: Validate withdrawal creation (Worker-only)
    function validateWithdrawalCreation(data) {
      return data.size() >= 7 &&
             data.keys().hasAll(['userId', 'amount', 'paymentMethod', 'paymentDetails', 'status', 'requestedAt', 'lastStatusUpdate']) &&
             data.amount is number &&
             data.amount >= 500 && // Minimum withdrawal
             data.amount <= 100000 &&
             (data.paymentMethod == 'UPI' || data.paymentMethod == 'BANK') &&
             data.paymentDetails is string &&
             data.paymentDetails.size() > 0 &&
             data.status == 'PENDING' &&
             data.requestedAt is timestamp &&
             data.lastStatusUpdate is timestamp;
    }

    // Helper: Validate withdrawal update (admin approval)
    function validateWithdrawalUpdate(oldData, newData) {
      return oldData.status == 'PENDING' &&
             (newData.status == 'APPROVED' || newData.status == 'REJECTED') &&
             newData.lastStatusUpdate is timestamp &&
             (newData.status == 'REJECTED' ? (newData.rejectionReason is string) : true) &&
             newData.userId == oldData.userId &&
             newData.amount == oldData.amount;
    }

    // ============================================
    // DEFAULT DENY (for any other collections)
    // ============================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
